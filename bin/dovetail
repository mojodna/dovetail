#!/usr/bin/env ruby

require 'rubygems'
require 'xmpp4r'
require 'xmpp4r/pubsub'
require 'open-uri'

class Component
  attr_reader :component, :settings

  DEFAULT_SETTINGS = {
    "component.domain" => "ubuntu.local",
    "component.host"   => "ubuntu.local",
    "component.port"   => 5288,
    "component.secret" => "secret",
    "component.status" => ""
  }

  def initialize(settings = {})
    @settings = DEFAULT_SETTINGS.merge(settings)

    @component = Jabber::Component.new(settings["component.domain"])

    setup_exception_handler
    setup_message_handler
    setup_presence_handler
    setup_iq_handler

    establish_connection
  end

  # TODO create 2 of these methods; one to handle deferred sends, the other to
  # actually deliver the stanzas
  def deliver(data)
    puts ">> #{data.to_s}"
    component.send(data)
  end

protected

  def establish_connection
    component.connect(settings["component.host"], settings["component.port"])
    component.auth(settings["component.secret"])
    puts "Connected"
  rescue Errno::ECONNREFUSED, Errno::ETIMEDOUT
    puts "Couldn't connect to Jabber server at #{settings["component.host"]}:#{settings["component.host"]}.
          That may mean the Jabber server isn't running or listening on that port,
          or there might be firewall issues. Exiting."
    exit 1
  rescue Jabber::AuthenticationFailure
    puts "Component authentication failed. Check your secret."
    exit 1
  end

  def setup_exception_handler
    component.on_exception do |e, stream, where|
      case where
      when :disconnected
        puts "Jabber service disconnected.  Shutting down."
        exit 1
      when :exit
        puts "Shutting down."
      else
        puts "Caught #{e.inspect} on #{stream} at #{where}.  You might want to consider handling this."
        raise e
      end
    end
  end

  def setup_message_handler
    # don't do anything here, but if / when we want to handle messages, do it here.
  end

  def setup_presence_handler
    component.add_presence_callback do |presence|
      case presence.type
      when :error

        puts "An error occurred: #{presence.to_s}"

      when :probe
        # client is probing us to see if we're online

        # send a basic presence response
        p = Jabber::Presence.new
        p.to = presence.from
        p.from = presence.to
        p.id = presence.id
        p.status = settings["component.status"]
        deliver(p)

      when :subscribe
        # client has subscribed to us

        # First send a "you're subscribed" response
        p = Jabber::Presence.new
        p.to = presence.from
        p.from = presence.to
        p.type = :subscribed
        p.id = presence.id
        deliver(p)

        # follow it up with a presence request
        p = Jabber::Presence.new
        p.to = presence.from
        p.from = presence.to
        p.id = "fe_#{rand(2**32)}"
        p.status = FIRE_EAGLE_CONFIG.jabber_status
        deliver(p)

        # Then send a "please let me subscribe to you" request
        p = Jabber::Presence.new
        p.to = presence.from
        p.from = presence.to
        p.type = :subscribe
        p.id = "fe_#{rand(2**32)}"
        deliver(p)

      when :subscribed
        # now we've got a mutual subscription relationship
      when :unavailable
        # client has gone offline

        update_presence("unavailable", presence.from)

      when :unsubscribe
        # client wants to unsubscribe from us

        # send a "you're unsubscribed" response
        p = Jabber::Presence.new
        p.to = presence.from
        p.from = presence.to
        p.type = :unsubscribed
        p.id = presence.id
        deliver(p)

      when :unsubscribed
        # client has unsubscribed from us
      else

        # client is available
        update_presence((presence.show || :online).to_s, presence.from)

      end
    end
  end

  def setup_iq_handler
    component.add_iq_callback do |iq|
      if iq.pubsub
        if items = iq.pubsub.first_element("items")
          items = Jabber::PubSub::Items.import(items)
          puts "Request for items on #{items.node}"

          # fetch items from the node url provided
          url = REXML::Text.unnormalize(items.node)
          response = open(url).read

          item = Jabber::PubSub::Item.new

          # attempt to treat as XML
          doc = REXML::Document.new(response)
          item.add(doc.root || REXML::CData.new(response))

          resp = iq.answer
          resp.type = :result
          resp.pubsub.first_element("items").add(item)
          deliver(resp)
        elsif create = iq.pubsub.first_element("create")
          node = create.attributes["node"]
          puts "Request for node creation: #{node}"

          resp = Jabber::Iq.new(:result, iq.from)
          resp.from = iq.to # TODO component.domain (elsewhere, too)
          resp.id = iq.id
          deliver(resp)
        else
          puts "Received a pubsub message"
          puts iq.to_s
          # TODO not-supported
          not_implemented(iq)
        end
      else
        # unrecognized iq
        not_implemented(iq)
      end
    end
  end

  def update_presence(presence, jid)
  end

  # respond to a request by claiming that it's not implemented
  def not_implemented(iq)
    resp = iq.answer
    resp.type = :error
    resp.add(Jabber::ErrorResponse.new("feature-not-implemented"))
    deliver(resp)
  end
end

component = Component.new

sleep 5 while true
